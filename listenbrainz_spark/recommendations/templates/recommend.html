<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>Recommendations</title>
<style>
table {
  font-family: arial, sans-serif;
  border-collapse: collapse;
  width: 100%;
}

td, th {
  border: 1px solid #dddddd;
  text-align: left;
  padding: 8px;
}
</style>
</head>
<body>
	<center>
		<h1>Generating recommendations</h1>
	</center>
	<p><b>all_recordings: </b>recordings_df which is a dataframe is used to create a new RDD called all_recordings which contains all the recording_ids as contained in recordings_df. Number of elements in all_recordings are equal to number of rows in recordings_df = <b>{{ all_recordings_count }}</b></p>
	<p><i><b>Note: </b>As 'rows' are to dataframes similarily 'elements' are to RDDs</i></p>
	<p>all_recordings can be depicted as: </p>
	<blockquote>
		<p>[ 1 ]</p>
		<p>[ 2 ]</p>
		<p>[ 3 ]</p>
	</blockquote>
	<p><i><b>Note: </b>recording_id are represented as [ x ] where x is an integer.</i></p>
	<p>Model used to generate recommendations is <b>{{ best_model }}</b> i.e. best model. Time taken to load best model is <b>{{ time.load_model }}m</b></p>
	<p>Sub-steps in generating recommendations for every user are as follows:</p>
	<ul>
		<li><p><b>get_user_id: </b>A query<b>(get_user_id)</b> is processed to get user id from the user name provided for whom the recommendations shall be generated.</p></li>
		<li><b>user_playcounts: </b><p>From the user id retrieved a user-playcounts dataframe is generated for every user, purpose of this dataframe is to get recording_ids of only those tracks that the user has ever listened to. The schema for user-playcounts dataframe is as follows:</p>
		<table>
		<tr>
			<th>user_id</th>
			<th>recording_id</th>
			<th>count</th>
		</tr>
		<tr>
			<td>1</td>
			<td>1</td>
			<td>2</td>
		</tr>
		</table>
		</li>
		<li><p><b>user_recordings: </b>The user-playcounts dataframe is used to create a new RDD called user_recordings which contains recording_ids of the tracks the user has ever listened to. user_recordings can be depicted as: </p>
		<blockquote>
			[ 1 ]
		</blockquote>
		<p><i>Since 'rob' has listened to one track of the three tracks ever listened by any user and the recording_id of that track is 1</i></p>
		</li>
		<li>
			<p><b>candidate_recordings: </b>An RDD called candidate_recordngs is created by subtracting user_recordings from all_recordings, therefore candidate_recordings will contain recording_ids of only those tracks that the user has <b>never</b> listened to. This RDD would then be used to predict recommendations for a user ensuring only new tracks (tracks that are new to a user) are recommended to a user.</p>
			<p>candidate_recordings can be depicted as: </p>
			<blockquote>
				<p>all_recordings - user_recordings ~</p>
				<p>[ 2 ]</p>
				<p>[ 3 ]</p>
			</blockquote>
			<p><i>'rob' has never listened to tracks with recording ids as 2 and 3. Therefore, he will be recommedned tracks from amongst these two.</i></p>
		</li>
		<li>
			<p><b>predictAll : </b>candidate_recordings is fed to Spark's inbuilt function 'predictAll' to predict tracks for users from the provided pool of recording_ids. The function returns recommended recording_ids. Let's say recording_id = 3 has been recommeded to 'rob'</p>
		</li>
		<li>
			<p><b>recommendations: </b>The last step is to lookup for information (track_name, artist_name etc) corresponding to the recommended recording_ids which can be retrieved using recordings_df dataframe. The following track will be recommended to 'rob': </p>
			<blockquote>
				<p>['Stand by me', 'b9da2ed1-6291-4b05-9e5e-b87551a8e75f', 'Ben E. King', '837555ba-012e-45f1-9a9c-9628da13ee54', 'Billboard Presents: Family Friendship Classics', '0fede8ca-7b38-455b-bde3-8a098c43031']</p>
			</blockquote>
		</li>
	</ul>
	<p>Following is the user wise time information:</p>
	<table>
		<col width="150">
		<tr>
			<th>user name</th>
			<th>get_user_id</th>
			<th>user_playcounts</th>
			<th>user_recordings</th>
			<th>candidate_recordings</th>
			<th>recommendations</th>
			<th>lookup</th>
			<th>total time</th>
		</tr>
		{% for user_name, user in recommendations.items() -%}
		<tr>
			<td>{{ user_name }}</td>
			<td>{{ user['get_user_id'] }}m</td>
			<td>{{ user['user-playcounts-time'] }}m</td>
			<td>{{ user['user-recordings-time'] }}m</td>
			<td>{{ user['candidate-recordings-time'] }}m</td>
			<td>{{ user['recommendations-time'] }}m</td>
			<td>{{ user['lookup-time'] }}m</td>
			<td>{{ user['total-time'] }}m</td>
		</tr>
		{% endfor -%}
	</table>
	<p>Following is the user wise count information:</p>
	<table>
		<col width="150">
		<tr>
			<th>user name</th>
			<th>user_recordings count</th>
			<th>candidate_recordings count</th>
		</tr>
		{% for user_name, user in recommendations.items() -%}
		<tr>
			<td>{{ user_name }}</td>
			<td>{{ user['user-recordings-count'] }}</td>
			<td>{{ user['candidate-recordings-count'] }}</td>
		</tr>
		{% endfor -%}
	</table>
	<p>Time taken in generating recommendations for all the above listed users: <b>{{ time.total_recommendation_time }}h</b></p>
	<p><b>Note</b>: Total time lapsed in data collection, data preprocessing, model training and generating recommendations is <b>{{ total_time }}h</b></p>
	<p>Following are the recommendations generated for the above listed users: </p>
	{% for user_name, user in recommendations.items() -%}
	<center>
		<h2>Recommendations for <b>{{ user_name }}</b></h2>
	</center>
	<table style="width:100%">
		<tr>
			{% for col in column -%}
			<th>{{ col }}</th>
			{% endfor -%}
		</tr>
		{% for recommended_recordings in user['recordings'] -%}
		<tr>
			{% for entity in recommended_recordings -%}
			<td>{{ entity }}</td>
			{% endfor -%}
		</tr>
		{% endfor -%}
	</table>
	{% endfor -%}
	<p><i><a href={{ prev }}>Prev</a></i></p>
</body>
</html>
